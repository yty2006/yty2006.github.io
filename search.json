[{"title":"CPT111-Week3","url":"//post/CPT111-Week3.html","content":"\n# *Week 3: Control Flow*\n\n\n\n## Exercise #3.1 Harmonic Numbers\n\n**Harmonic numbers** are a sequence of numbers that arises in various fields of mathematics.\nThe **n**-th harmonic number, denoted as `*Hn*`, is defined as the sum of the reciprocals of the first **n** natural numbers:\n![img](/img/image (2) (2).png)\nWrite a Java program *HarmonicNumber* that on input a positive integer *n*, prints the *n* -th harmonic number.\n\n\n\n###### Test case 1:\n\n| Input: | Output: |\n| ------ | ------- |\n| 2      | 1.5     |\n\n\n\n###### Test case 2:\n\n| Input: | Output:            |\n| ------ | ------------------ |\n| 10     | 2.9289682539682538 |\n\n\n\n###### My code:\n\n```java\nimport java.util.*;\npublic class hns {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        double n = sc.nextInt(), sum = 0, num = 1;\n        while ( num <= n ) {\n            sum += 1/num;\n            num ++;\n        }\n        System.out.println(sum);\n    }\n}\n\n```\n\n## Exercise #3.2 Black Jack\n\nIn Black Jack card game, we call a value *busts* if it exceeds a sum of 21.\nWrite a Java program *BlackJack* that on input 2 integer values greater than 0,\nprints a single integer of whichever value is nearest to 21 without going bust.\nPrint -1 if both values bust.\n![img](/img/Blackjack-Cards-Image.png)\n\nFor example:\n\n| Input | Result |\n| :---- | :----- |\n| 20 19 | 20     |\n| 19 22 | 19     |\n| 22 23 | 1      |\n\n\n\n###### My code:\n\n```java\nimport java.util.*;\n\npublic class blkjack {\n    public static void main(String[] args) {\n        int a, b;\n        Scanner sc = new Scanner(System.in);\n        a = sc.nextInt();\n        b = sc.nextInt();\n        if(a>=b){\n            if(a<22)\n                System.out.println(a);\n            else if(b<22)\n                System.out.println(b);\n            else System.out.println(-1);\n        }\n        else if(a<b) {\n            if(b<22)\n                System.out.println(b);\n            else if(a<22)\n                System.out.println(a);\n                else System.out.println(-1);\n        }\n    }\n}\n\n```\n\n\n\n## Exercise #3.3 Pandemic Spread\n\nWrite a Java program *PandemicSpread* to simulate how *fast* a pandemic spread with the following input:\ninit : the initial number of infected persons on day 1numInfect : the average number of healthy people that one infected person newly infects per daypopulation : the total number of people in the areaReturn the day on which the *entire* population will be infected.\n\n![img](/img/pandemicspread.png)\n\nFor example:\n\n| Input    | Result |\n| :------- | :----- |\n| 1 2 10   | 4      |\n| 5 3 1000 | 5      |\n\n\n\n###### My code:\n\n```java\nimport java.util.*;\n\npublic class pandsp {\n    public static void main(String[] args) {\n        int init, numInfect, population, day = 1;\n        Scanner sc = new Scanner(System.in);\n        init = sc.nextInt();\n        numInfect = sc.nextInt();\n        population = sc.nextInt();\n        while(init < population){\n            init += numInfect*init;\n            day ++;\n        }\n        System.out.println(day);\n    }\n}\n\n```\n\n\n\n## Exercise #3.4 Right Triangle\n\nWrite a Java program RightTriangle that takes three integer input numbers and determines whether they make up the side lengths of a right triangle .\n![img](/img/right-triangle1.png)\n\nYour program must print output true if and only if the following two conditions are true :\n\n1) All three integers are positive (greater than zero).\n2) You can find two integers where the sum of the squares of those two integers is equal to the square of the third integer.\n\n\n\nFor example:\n\n| Input   | Result |\n| :------ | :----- |\n| 5 12 13 | true   |\n| 5 4 3   | true   |\n| -3 -4 5 | false  |\n\n\n\n###### My code:\n\n**(a bit strange tho, but it works)**\n\n```java\nimport java.util.Scanner;\npublic class RT {\n    public static void main(String[] args) {\n        int a, b, c;\n        Scanner sc = new Scanner(System.in);\n        a = sc.nextInt();\n        b = sc.nextInt();\n        c = sc.nextInt();\n        System.out.println((a>0 && b>0 && c>0 )&&(a > b && a > c && a * a == b * b + c * c || b > a && b > c && b * b == a * a + c * c || c > a && c > b && c * c == b * b + a * a));\n    }\n}\n\n```\n\n\n\n## Lab Exercise #3.1 Armstrong Number\n\nAn Armstrong number is an *n*-digit number that equals the sum of the *n*th power of its digits.\nFor example,\n\n- 153 is a three-digit number where the sum of the cubes of the individual digits equal\n- 1531634 is a four-digit number where the sum of the 4th power of the individual digits equal 1634![img](/img/image (4).png)\n\nWrite a Java program *Armstrong* that on input two positive integers *a* and *k*,\nprints the first *k* Armstrong numbers greater than or equal to *a*.\n\n\n\nFor example:\n\n| Input  | Result  |\n| :----- | :------ |\n| 100 2  | 153 370 |\n| 1500 1 | 1634    |\n\n\n\n###### My code:\n\n```java\nimport java.util.Scanner;\n\npublic class Armstrong {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int a = sc.nextInt();\n        int k = sc.nextInt();\n        int sum = 0;\n        while (k != 0) {\n            int num = a;\n            String str = Integer.toString(num);\n            int length = str.length();\n            while (num > 0) {\n                int digit = num % 10;\n                num = num / 10;\n                sum += Math.pow(digit, length);\n            }\n            if (sum == a) {\n                k--;\n                System.out.println(sum);\n            }\n            a ++;\n            sum = 0;\n        }\n    }\n}\n```\n\n\n\n## Lab 3 Challenge - Hailstone Sequence Length\n\nThe *Hailstone sequence* is computed as follows:\n\n- Start with an integer number nIf n is even, the next number in the sequence is n/2\n- If n is odd, the next number is 3n+1\\\n- Continue until it reaches 1For example,\n  for n = 3, the sequence is 3, 10, 5, 16, 8, 4, 2, 1\n  and for n = 12, the sequence is 12, 6, 3, 10, 5, 16, 8, 4, 2, 1\n\n![img](/img/Hailstone.png)\n\nWrite a Java program *HailStone* that on input a positive integer n, prints the ***length*** of the Hailstone sequence starting at n.\n\n\n\nNote that, interestingly, we still do *not* know whether the Hailstone sequence will ever reaches 1 for all starting n !\nThis is also known in the literature as the *Collatz conjecture*.\n\n\n\n\n\nFor example:\n\n| Input | Result |\n| :---- | :----- |\n| 3     | 8      |\n| 12    | 10     |\n\n\n\n###### My code:\n\n```\nimport java.util.Scanner;\n\npublic class Hailstone {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(), l = 1;\n        while (n != 1) {\n            if (n % 2 == 0) {\n                n /= 2;\n                l ++;\n            }\n            else {\n                n = 3 * n + 1;\n                l ++;\n            }\n        }\n        System.out.println(l);\n    }\n}\n\n```\n\n","tags":["Java"],"categories":["learning"]},{"title":"CPT111-Week2","url":"//post/CPT111-Week2.html","content":"\n## *Week 2: Data Types, Math, Client Input, Debugging*\n\n\n\n### Exercise #2.1 What day is it?\n\nWrite a Java program that takes a date as input and prints the day of the week that date falls on.\n\nYour program should take three integers: y (year), m (month), and d (date).\nFor m use 1 for January, 2 for February, and so on.\nFor output print 0 for Sunday, 1 for Monday, 2 for Tuesday, and so on.\n\nUse the following formulas:\n\n![](/img/whatdayisit.png)\n\nTest case 1:\n\n| Input:             | Output:      |\n| ------------------ | ------------ |\n| 2018<br/>12<br/>24 | It's day 1 ! |\n\n\n\n\n\n###### My code:\n\n```java\nimport java.util.*;\npublic class wdis {\n    public static void main(String[] args) {\n        int y,m,d,a,b,c,day;\n        Scanner sc=new Scanner(System.in);\n        y = sc.nextInt();\n        m = sc.nextInt();\n        d = sc.nextInt();\n        a = y - (14 - m)/12;\n        b = a + a/4 - a/100 + a/400;\n        c = m + 12 * ((14 - m)/12) - 2;\n        day = (d + b +(31*c)/12) % 7;\n        System.out.println(\"It's day \" + day +\" !\");\n    }\n}\n\n```\n\n\n\n### Exercise #2.2 Great Circle Distance\n\nThe *great-circle distance* is the length of the shortest path between two points (x1,y1) and (x2,y2) on the surface of a sphere. \n\nThe formula is given below.\n\n![](/img/greatcircledist.png)\n\nWrite a Java program that takes four double input numbers x1, y1, x2, y2, which are the latitude and longitude in degrees of two points on the surface of the Earth;\nuses the mean radius of the Earth \n\n\n\n*r = 6,371.0*  kilometres;\nand prints the great-circle distance *dist* between them in kilometres.\n\nNote that the input numbers are given in degrees but Java’s trigonometric functions use radians. Use `Math.toRadians()` to convert from degrees to radians.\n\n###### Test case 1:\n\n| Input:                            | Output:                      |\n| --------------------------------- | ---------------------------- |\n| 80.0<br/>25.0<br/>155.0<br/>102.5 | 7509.440708014122 kilometres |\n\n\n\nTest case 2:\n\n| Input:                              | Output:                      |\n| ----------------------------------- | ---------------------------- |\n| 10.55<br/>39.33<br/>21.47<br/>-7.88 | 5169.256612492542 kilometres |\n\n\n\n\n###### My code:\n\n```java\nimport java.util.*;\n\npublic class GCD {\n    public static void main(String[] args) {\n        double x1,y1,x2,y2,dist;\n        Scanner sc = new Scanner(System.in);\n        x1 = Math.toRadians(sc.nextDouble());\n        y1 = Math.toRadians(sc.nextDouble());\n        x2 = Math.toRadians(sc.nextDouble());\n        y2 = Math.toRadians(sc.nextDouble());\n        dist = 2*6371.0*Math.asin(Math.sqrt(Math.sin((x2-x1)/2)*Math.sin((x2-x1)/2) + Math.cos(x1)*Math.cos(x2)*Math.sin((y2-y1)/2)*Math.sin((y2-y1)/2)));\n        System.out.println(dist + \" kilometres\");\n    }\n}\n\n```\n\n\n\n## Exercise #2.3 Area of a Pentagon\n\nWrite a Java program that computes the area of a pentagon, given `*r*` = the length from the center of a pentagon to a vertex (a real number).\n![img](/img/image.png)\n\nThe formula of computing the area of a pentagon is:\n![img](/img/image (1).png)\n\nwhere `*s*` is the length of a side, computed with the formula:\n![img](/img/image (2).png)\n\n\n\n###### Test case 1:\n\n| Input: | Output:                  |\n| ------ | ------------------------ |\n| 2.5    | Area = 14.86025806711178 |\n\n###### Test case 2:\n\n| Input: | Output:                  |\n| ------ | ------------------------ |\n| 1.0    | Area = 2.377641290737884 |\n\n\n\n###### My code:\n\n```java\nimport java.util.*;\n\npublic class AP {\n    public static void main(String[] args) {\n        double r,s,area;\n        Scanner sc = new Scanner(System.in);\n        r = sc.nextDouble();\n        s = 2*r*Math.sin(Math.PI/5);\n        area = (5*s*s)/(4*Math.tan(Math.PI/5));\n        System.out.println(\"Area = \" + area);\n    }\n}\n\n```\n\n\n\n## CW1 #2.1 YIQ to RGB\n\nThere are several different formats used to represent color. You may have known the *RGB format* that specifies the level of red (R), green (G), and blue (B) on an ***integer*** scale from 0 to 255. You have learned about CMYK format in Lab 2.\n\nThere is another format called the **YIQ** that is used in analog TV broadcasting. It specifies the luminance (Y), in-phase (I), and quadrature (Q) on a ***real*** scale from with 0.0 ≤ Y ≤ 1.0, –0.5957 ≤ I ≤ 0.5957, and –0.5226 ≤ Q ≤ 0.5226.\n\n![img](/img/image (3).png)\n\n\n\nWrite a Java program that converts from YIQ format to RGB format using the following steps.\n\n**Step 1:**\nCompute the values of R, G, B in double using the following formula:\n\n![img](/img/image (2) (1).png)\n\n\n\n**Step 2:** Round the double values to the nearest int values.\n\n**Step 3:**\nUsing **Math.min** function, make sure that the *largest* possible resulting value is 255; and using **Math.max** function, make sure that the *smallest* possible resulting value is 0.\n\nYour program must take three **double** input numbers Y, I, and Q; compute the corresponding RGB values, and print the RGB values as in the test cases below:\n\n\n\n###### Test case 1:\n\n| Input:              | Output:                                 |\n| ------------------- | --------------------------------------- |\n| 0.5<br/>0.5<br/>0.5 | red = 255<br/>green = 10<br/>blue = 204 |\n\n\n\n###### Test case 2:\n\n| Input:                 | Output:                             |\n| ---------------------- | ----------------------------------- |\n| 0.0<br/>0.25<br/>-0.50 | red = 0<br/>green = 65<br/>blue = 0 |\n\n\n\n###### My code:\n\n```java\nimport java.util.*;\n\npublic class YIQ2RGB {\n    public static void main(String[] args) {\n        double y,i,q;\n        int r,g,b;\n        Scanner sc = new Scanner(System.in);\n        y = sc.nextDouble();\n        i = sc.nextDouble();\n        q = sc.nextDouble();\n        r = Math.toIntExact(Math.round((y + 0.956 * i + 0.619 * q) * 255));\n        g = Math.toIntExact(Math.round((y - 0.272 * i - 0.647 * q) * 255));\n        b = Math.toIntExact(Math.round((y - 1.106 * i + 1.703 * q) * 255));\n        if(r>255) r =255;\n        if(r<0) r=0;\n        if(g>255) g =255;\n        if(g<0) g=0;\n        if(b>255) b =255;\n        if(b<0) b=0;\n        System.out.println(\"red = \" + r);\n        System.out.println(\"green = \" + g);\n        System.out.println(\"blue = \" + b);\n    }\n}\n\n```\n\n","tags":["Java"],"categories":["learning"]},{"title":"CPT111-Week1","url":"//post/CPT111-Week1.html","content":"\nSimply started my learning process right here.\n\n![](/img/W1_1.png)\n\n```java\nimport java.util.*;\n\npublic class LoveThreeThousands {\n    public static void main(String[] args) {\n        int threeThousands = 3000;\n        System.out.println(\"\\\"I love you \"+threeThousands+\".\\\"\");\n    }\n}\n```\n\n","tags":["Java"],"categories":["learning"]},{"title":"test","url":"//post/test.html"},{"title":"Some thinking related to linear algebra","url":"//post/Some thinking related to linear algebra.html","content":"\n## 向量空间\n\n- 最常见的向量空间（线性空间）：$R^n$。\n\n定义：一个向量构成的集合$X$，其中选择任意两个向量，它们的<u>[*线性组合*](#线性组合)</u>仍在这个空间内（$X$有封闭性）。\n\n- ### 线性组合\n\n  对于向量空间$X$，其中两个向量$v，w \\in X$的线性组合为$av+bw$，其中$a,b\\in F$，$F$为标量域。\n\n## 向量\n\n数学意义上，在线性空间中的元素就是向量。\n\n也可以这么说：把一组数字同时乘一个数，同时加一个数，并且把两组数字按位置对应相加这两种计算都是有意义的，那么这组数字就是就是一个向量。\n\n\n\n对于向量有很多种理解方式，比如它可以是空间中可以自由移动的有方向的箭头，可以是有序的数组，\n","tags":["math"],"categories":["math"]},{"title":"对Algebra的理解","url":"//post/对Algebra一书的理解.html","content":"\n## **详见[https://math.tianyang.eu.org](https://math.tianyang.eu.org)**\n\n[**说明**](http://math.tianyang.life/#/?id=说明)\n\n> 关于本卷\n\n这里主要记录笔者关于B.L. 范德瓦尔登所著的《代数学I》与《代数学II》的思考和想象\n\n> 一些概念的关系图\n\n![img](/al0.jpg)\n","tags":["Math"],"categories":["archives"]},{"title":"思维导图","url":"//post/思维导图.html","content":"\n![](/机械能守恒-non.png)\n\n------\n\n[图片](/机械能守恒.png)\n","tags":["物理"],"categories":["math"]},{"title":"bcd命令的用法","url":"//post/bcd命令的用法.html","content":"\n## 什么是**BCD**\n\n  - **BCD**全称**Boot Configuration Data**，意思是**启动配置数据**\n\n**BCD**的作用\n\n  - 里边包含启动磁盘信息，分区的GUID，启动需要的EFI文件路径，系统路径（默认为\\WINDOWS），安全启动选项，PAE，XN，超时时间，启动界面语言，系统语言，设备文件，SDI等重要信息\n\n  - **BCD**不仅可以启动Windows操作系统，还可以引导WindowsPE（废话），Linux，Grub引导菜单，WIM镜像文件，chameleon（变色龙引导的黑苹果）等\n\n**BCD**缺失或损坏会导致蓝屏和进不去OS等问题\n\n这时，你有这几种选择：\n\n1. 进**WinPE**，用自带的修复工具\n2. 进**Windows RE**或用刷好Windows安装U盘（光盘）启动，进高级选项 ->CMD，用**bcdedit**，**bcdboot**等命令修复\n3. 重装Windows\n4. 换电脑\n\n本篇要讲的就是**BCD**的常用命令（如有错误请在评论区指出）\n","tags":["cmd"],"categories":["tech"]},{"title":"解决VMware Unlocker无法下载darwin.iso的问题","url":"//post/解决VMware Unlocker无法下载darwin.iso的问题.html","content":"\n之前装了Windows11,结果搞黑苹果虚拟机时发现Apple Mac OS X选项没了...\n\n于是我用最快速度找到**MK-unlocker**并下载\n\n然后在Getting VMware Tools中pip下载超时\n\n重试后一直找不到正确地址\n\n![pic-1](/img/pic-1.png)\n\n<!-- more -->\n\n我到网站找到了它的下载方式↓\n\n![image](/img/pic-2.png)\n\n最终找到VMware Fusion的最新软件包\n\n![image-20210804175755306](/img/pic-3.png)\n\n下载后,我发现MK-unlocker好使了\n\n*下载好的tools文件夹如图*\n\n![image-20210804180030561](/img/pic-4.png)\n\n进软件包一搜,就会发现实际上就用这么几个文件\n\n![image-20210804180345558](/img/pic-5.png)\n\n就这两个镜像文件有用\n\n![image-20210804180418057](/img/pic-6.png)\n\n把文件解压到tools文件夹就可以正常使用\n\n如有需要提供修改后unlocker下载: [Cloud](https://file.tianyang.life/d/%E6%9C%AC%E5%9C%B0/unlocker-3.0.2.zip)\n\n~~**是时候清理一下网站落的灰了[手动狗头]**~~\n","tags":["黑苹果"],"categories":["tech"]},{"title":"【转载】从Clover到OpenCore","url":"//post/【转载】从Clover到OpenCore.html","content":"\n【转载】从Clover到OpenCore\n 2020-04-14 |  2020-05-13 |  教程 |  84181\n 21k |  38 分钟\n\n由于是转载文章，文章中的我特指作者：SukkaW\n\n随着 OpenCore 日渐成熟、acidanthera 团队宣布放弃旗下绝大部分内核驱动（包括 Lilu、VirtualSMC、WhateverGreen、AppleALC 等）对 Clover 的兼容性支持，与其届时被迫换到 OpenCore，不如主动开始迁移。\n\n当然面对迁移，有的人会选择直接抛弃之前 Clover 的全部成果，直接从零开始配置 OpenCore。但是我相信对于大部分人来说更希望通过简简单单的修补，在现有的 EFI 的基础上迁移到 OpenCore，因此我开始撰写这篇文章。\n\n<!-- more -->\n\n然而不幸的是从 Clover 切换到 OpenCore 并不是一个简单的任务，因此这种迁移应该是渐进式的，不可能一蹴而就。那什么是「渐进式」呢？意思就是，如果你按照本文的步骤一步一步按顺序进行，那么大部分迁移步骤产生的修改，在 Clover 下一样可用，你不需要一下子就扔掉 Clover 。\n\n序言以外应该写在最前面的话\nOpenCore 丢掉了不少 Clover 的历史包袱。毫无疑问依然有不少 Clover 设置在 OpenCore 是没有可以直接替代的。因此 Clover 完全照搬到 OpenCore 是肯定行不通的。\n在迁移到 OpenCore 之前，Clover 的大部分设置都要精简：用 SSDT 代替、改为注入设备属性（Device Properties）。这篇教程的主题就是教你这些事情。\n如果你一开始在组织 Clover 的 EFI 时就有洁癖的话，你会发现迁移到 OpenCore 出人意料地简单。\n只有完美的 Clover 的 EFI，在按照本文档的步骤精简后能获得完美的 OpenCore 的 EFI。如果你的 EFI 是不完美的，那么迁移到 OpenCore 也一定是不完美的。因此，如果你是为了解决不完美、才想迁移到 OpenCore，那么我建议先在 Clover 下完善。\n独木难成林。这篇教程初次发布以后，Bat.bat 等许多大佬在远景论坛、Telegram 上提供了许多意见，正是在他们的帮助下，这篇教程得以不断完善。\n修改 SSDT / DSDT 以搭配 OpenCore\nOpenCore 和 Clover 最大的不同其实是，acidanthera 决定在 OpenCore 中设置的 SMBIOS 机型信息、DSDT 和 SSDT，都将一视同仁的对所有操作系统生效。这样做的目的是让黑苹果更像白苹果，但是却有可能导致在 macOS 上正常可用的 ACPI 表到了 Windows 上反而会出问题。因此，迁移的第一步我个人推荐从修改现有的 SSDT 和 DSDT 开始，因为在 OpenCore 下能用的 SSDT、DSDT，在 Clover 下是一定可用的。也就是说，当你完成这一步后，你可以继续使用 Clover 而不受影响。\n\n这里主要介绍对 Method 函数的修改方法。以 GPRW（6D0D）补丁为例，在 Clover 上我们一般采用这种方法：\n\n//\n// In config ACPI, GPRW to XPRW\n// Find:     47505257 02\n// Replace:  58505257 02\n//\nDefinitionBlock (\"\", \"SSDT\", 2, \"SUKA\", \"GPRW\", 0)\n{\n    External(XPRW, MethodObj)\n    Method (GPRW, 2, NotSerialized)\n    {\n        If ((0x6D == Arg0))\n        {\n            Return (Package ()\n            {\n                0x6D, \n                Zero\n            })\n        }\n\n        If ((0x0D == Arg0))\n        {\n            Return (Package ()\n            {\n                0x0D, \n                Zero\n            })\n        }\n        Return (XPRW (Arg0, Arg1))\n    }\n}\n这个 SSDT 的原理是，通过 DSDT 重命名将原始的 GPRW,2 函数重命名为 XPRW,2 ，然后通过 SSDT 新增一个 GPRW 函数，这样实际 ACPI 调用 GPRW 函数时就是调用的 SSDT 里添加的 GPRW 函数。\n\n但是现在，OpenCore 将会对所有操作系统一视同仁，所有 SSDT、DSDT 重命名对包括 Windows 在内的所有操作系统生效，那么 SSDT 中的 GPRW 函数也会在 Windows 生效，可能就会导致未知的后果。所以，我们需要通过 OSI 函数，判断当前操作系统，确保函数的行为只对某一个操作系统生效：\n\n//\n// In config ACPI, GPRW to XPRW\n// Find:     47505257 02\n// Replace:  58505257 02\n//\n// 需要注意的是，ACPI 里不支持非 ASCII 字符注释，这里仅做示例，不可直接用于编译\nDefinitionBlock (\"\", \"SSDT\", 2, \"OCLT\", \"GPRW\", 0)\n{\n    External(XPRW, MethodObj) // 对 XPRW 函数的外部引用\n    Method (GPRW, 2, NotSerialized)\n    {\n        If (_OSI (\"Darwin\")) // 如果当前的操作系统是 macOS，生效以下行为\n        {\n            If ((0x6D == Arg0))\n            {\n                Return (Package ()\n                {\n                    0x6D, \n                    Zero\n                })\n            }\n\n            If ((0x0D == Arg0))\n            {\n                Return (Package ()\n                {\n                    0x0D, \n                    Zero\n                })\n            }\n        }\n        // 否则，直接返回 XPRW 函数。只有三种情况下会走到这一步：\n        // 第一个参数不是 0x6D、第一个参数不是 0x0D、当前操作系统不是 macOS\n        // XPRW 是 ` DSDT ` 中原始的 GPRW 函数重命名而来\n        // 所以这一步实际上是调用了原始 ` DSDT ` 中原始的 GPRW 方法\n        Return (XPRW (Arg0, Arg1))\n    }\n}\n上面以 GPRW 为例介绍了相关思路，接下来我们以亮度快捷键补丁为例实际操作一下如何一步一步修改 SSDT。大部分亮度快捷键都是基于 EC Query 触发的，因此在 Clover 中我们的亮度快捷键 SSDT 可能是这样的：\n\n// In config ACPI, _Q14 renamed XQ14\n// Find:     5F 51 31 34\n// Replace:  58 51 31 34\n\n// In config ACPI, _Q15 renamed XQ15\n// Find:     5F 51 31 35\n// Replace:  58 51 31 35\n\nDefinitionBlock(\"\", \"SSDT\", 2, \"SUKA\", \"BrightFN\", 0)\n{\n    External(_SB.PCI0.LPCB.KBD, DeviceObj)\n    External(_SB.PCI0.LPCB.EC, DeviceObj)\n    \n    Scope (_SB.PCI0.LPCB.EC)\n    {\n        Method (_Q14, 0, NotSerialized)//up\n        {\n            Notify(\\_SB.PCI0.LPCB.KBD, 0x0406)\n        }\n    \n        Method (_Q15, 0, NotSerialized)//down\n        {\n            Notify(\\_SB.PCI0.LPCB.KBD, 0x0405)\n        }\n    }\n}\n如果想知道亮度快捷键补丁的工作原理，请参看我的另一篇文章「黑苹果自定义键盘 Fn 快捷键」。\n\n根据同样的思路，我们先在 Method 定义中添加 OSI 函数判断操作系统：\n\nDefinitionBlock(\"\", \"SSDT\", 2, \"hack\", \"BrightFN\", 0)\n{\n    External(_SB.PCI0.LPCB.KBD, DeviceObj)\n    External(_SB.PCI0.LPCB.EC, DeviceObj)\n    \n    Scope (_SB.PCI0.LPCB.EC)\n    {\n        Method (_Q14, 0, NotSerialized)//up\n        {\n+            If (_OSI (\"Darwin\"))\n+            {\n                  Notify(\\_SB.PCI0.LPCB.KBD, 0x0406)\n+            }\n        }\n        \n        Method (_Q15, 0, NotSerialized)//down\n        {\n+            If (_OSI (\"Darwin\"))\n+            {\n                  Notify(\\_SB.PCI0.LPCB.KBD, 0x0405)\n+            }\n        }\n    }\n        }\n        由于这里不是以 Return 结束的，所以我们要为 If 加上 Else：\n\nDefinitionBlock(\"\", \"SSDT\", 2, \"hack\", \"BrightFN\", 0)\n{\n    External(_SB.PCI0.LPCB.KBD, DeviceObj)\n    External(_SB.PCI0.LPCB.EC, DeviceObj)\n\n    Scope (_SB.PCI0.LPCB.EC)\n    {\n        Method (_Q14, 0, NotSerialized)//up\n        {\n+            If (_OSI (\"Darwin\"))\n+            {\n                  Notify(\\_SB.PCI0.LPCB.KBD, 0x0406)\n+            } Else {\n+\n+            }\n        }\n        \n        Method (_Q15, 0, NotSerialized)//down\n        {\n+            If (_OSI (\"Darwin\"))\n+            {\n                  Notify(\\_SB.PCI0.LPCB.KBD, 0x0405)\n+            } Else {\n+\n+            }\n        }\n    }\n        }\n        在 Else 区域中，调用原始 DSDT 中原始的 _Q14、_Q15 函数、也就是现在已经被重命名为 XQ14 和 XQ15 的函数。当然，别忘了在文件头部添加对 XQ14 和 XQ15 的函数的外部引用：\n\nDefinitionBlock(\"\", \"SSDT\", 2, \"hack\", \"BrightFN\", 0)\n{\n    External(_SB.PCI0.LPCB.KBD, DeviceObj)\n    External(_SB.PCI0.LPCB.EC, DeviceObj)\n+    External(_SB.PCI0.LPCB.EC.XQ14, MethodObj)\n+    External(_SB.PCI0.LPCB.EC.XQ15, MethodObj)\n     \n    Scope (_SB.PCI0.LPCB.EC)\n    {\n        Method (_Q14, 0, NotSerialized)//up\n        {\n+            If (_OSI (\"Darwin\"))\n+            {\n                  Notify(\\_SB.PCI0.LPCB.KBD, 0x0406)\n+            } Else {\n+                  \\_SB.PCI0.LPCB.EC.XQ14()\n+            }\n        }\n        \n        Method (_Q15, 0, NotSerialized)//down\n        {\n+            If (_OSI (\"Darwin\"))\n+            {\n                  Notify(\\_SB.PCI0.LPCB.KBD, 0x0405)\n+            } Else {\n+                  \\_SB.PCI0.LPCB.EC.XQ15()\n+            }\n        }\n    }\n        }\n        这样就大功告成了。\n\n是不是有些头昏脑涨？实际上，和 Clover 现成的 SSDT 补丁库一样，OpenCore 也有现成的 SSDT 补丁库 OC-little，由资深黑苹果爱好者们维护。我也在其中贡献了一些补丁（如 PTWSAK 关机变重启修复）和说明。 你在 Clover 中使用的 SSDT 补丁，大部分都有对应的 OpenCore 下可用的 SSDT 替代，免去了你手动修改的痛苦。而且，你还可能通过 OC-little 库里的其他补丁修复了一些你之前的 SSDT 补丁没有解决的问题。\n\n当然，对于一些 OC-little 中没有等价替代的补丁，你仍然需要手动修改、添加操作系统判断；对于直接修补的 DSDT，你也只能自己在 Method 中添加对应的判断。\n\n如果你完成了对 SSDT、DSDT 的修改，现在备份你的 EFI、然后修改后的 SSDT、DSDT 放到 EFI/Clover/ACPI/patched 之中，然后以 -v 重启，看看能不能正常开机。如果可以正常开机，登录以后打开终端执行以下命令、查看日志中是否包括 ACPI Error：\n\n$ log show --last boot | grep -Ei \"ACPI\"\n如果正常开机，没有 ACPI Error，那么恭喜你，你已经迈出了向 OpenCore 迁移的第一步，而且此时你依然还在继续使用 Clover ，你的黑苹果没有收到任何影响。\n\n减少不必要的 DSDT 重命名\nacidanthera 团队认为，应该尽可能减少 DSDT 重命名、减少改动以避免对设备硬件造成伤害。\n\n以下是一些不再需要的重命名，你可以参考这个表自己精简 DSDT 重命名、使用 SSDT 代替：\n\nEHC1 to EH01 和 EHC2 to EH02 ：建议由 OpenCore 官方的 SSDT-EHCx_OFF 关闭 EHC 控制器。Skylake 这类六代以上已经没有 EHC 控制器了，可以直接删除。\nSAT0 to SATA 和 SAT1 to SATA ：实质上完全没用。\nHECI to IMEI、HEC1 to IMEI、MEI to IMEI 和 IDER to MEID：WhateverGreen 能够处理这个问题。\nGFX0 to IGPU、PEG0 to GFX0、PEGP to GFX0 和 SL01 to PEGP：WhateverGreen 能够处理这个问题。\nEC0 to EC、H_EC to EC、ECDV to EC 和 PGEC to EC ：虽然 macOS 的 USB 电源管理需要名称为 EC 的控制器，但是你完全可以在 OC-little 中找到「仿冒 EC」的相关 SSDT 补丁。\nHDAS to HDEF、CAVS to HDEF 和 AZAL to HDEF ：AppleALC 能够处理这个问题，除非你在用 VoodooHDA 万能声卡。\nSTAS to Noop ：建议由 OC-little 中的 SSDT-AWAC 相关补丁替代。\n经 Bat.bat 大佬指出，由于新的时钟设备 AWAC 的普及，用 Noop 会导致同时启用两个时钟设备，在 macOS 下只有一个能正常工作、但是在 Windows 下面暴露两个设备无疑对系统有害，同时也严重违反 ACPI 规范。STAS 这个变量的意义使 AWAC 和 RTC 互锁以避免这种危害。因此，使用 SSDT-AWAC 是更理想的办法。\n\nPXSX to ANS1 和 PXSX to ANS2 ：建议用 NVMeFix 这个 kext 修复 NVMe SSD 的电源管理。\nLPC0 to LPCB ：如果你要添加 SMBUS 支持，OC-little 中分别有 SBUS 的 SSDT 注入补丁和 MCHC 设备补丁。\n顺便提醒一下，使用 OC-little 的补丁的时候，需要注意设备的原始 DSDT 中的 LPC 总线名称，并且要自己修改 SSDT 以使 LPC 总线匹配。\n\nPC00 to PCIO、FPU to MATH、TMR to TIMR、GBE1 to ETH0 和 PIC to IPIC ：这些重命名也是实质上是完全没用的。\n_OSI to XOSI 和 OSID to XSID ：除非你的某些硬件设备只能在 Windows 下工作（比如 I2C 触摸板只能在 Windows 下使用，再比如 ThinkPad 对 FreeBSD 的特殊优化），否则完全没有必要使用 SSDT-XOSI 补丁来伪装操作系统。而且大部分情况下，直接定制 SSDT 也可以解除某些硬件的操作系统限制。\n关于「定制 SSDT 以解除限制」，Bat.bat 大佬做了一些说明：一种方法是通过「预置变量法」（详见 OC-little 的「总述」章节）禁用原始设备的函数如 _STA，另一种方法是通过重命名实现对相关 _STA 的函数的精确重命名，然后通过 SSDT 添加新的 _STA 函数（SSDT 中可以添加 OSI 操作系统判断函数）。\n\n_DSM to XDSM ：首先遍历一下你的 SSDT 补丁中没有依赖 _DSM 的，如果没有，这个重命名也应该删除，因为这个重命名涉及的范围实在太大了、太过于危险。\n我的建议是，尽可能只添加和 Method 名称有关的重命名（如 GPRW to XPRW、_Q14 to XQ14），而且随后要通过 SSDT 确保在非 macOS 操作系统下要调用并返回原始函数，确保在非 macOS 操作系统下的原始 DSDT 行为不会被改变。如果万不得已要添加其它重命名（如通过重命名禁用某些设备），那么就要权衡这一重命名的后果。\n\n如果你完成了精简 DSDT 重命名并保存了 config，接下来的操作还是一样的，备份原始 EFI、然后以 -v 重启，看看能不能正常开机。如果可以正常开机，登录以后打开终端执行以下命令、查看日志中是否包括 ACPI Error：\n\n$ log show --last boot | grep -Ei \"ACPI\"\n完成这一步，你依然没有必要离开 Clover 。我说过了，「渐进式」地迁移，嗯？\n\n摆脱对 Clover ACPI Quirks 的依赖\nClover 实在是非常方便。一个开关，关机变重启就修复了；三个开关，HPET、IRQ、TIMR 就修复了；等等等等。但是 OpenCore 是没有内置这些 ACPI 修复的，所以在 Clover 下用开关实现的 ACPI 修复现在都必须用 SSDT 实现。所幸的是，我们依然可以从 OC-little 里找到绝大部分我们需要的补丁。\n\nFixIPIC：参考 OC-little 的「声卡 IRQ 补丁」章节\nFixSBUS：参考 OC-little 的「注入 SBUS 设备」\nFixShutdown：参考 OC-little 的「PTSWAK 综合补丁章节」，需要添加其中的 EXT1 插件补丁（该补丁由我贡献）\nFixDisplay：使用 WhateverGreen 和定制缓冲帧补丁解决\nAddMCHC：参考 OC-little 的「注入缺失的 MCHC」章节\nFixHDA：使用 AppleALC 即可\nFixHPET：参考 OC-little 的「声卡 IRQ 补丁」章节\nFixSATA：这个先不管它，OpenCore 中有个 ExternalDiskIcons 的 Quirk，也可以使用 innie.kext 解决。\nFixADP1：使用 DSDT 重命名 AC0_ to ADP1，可能还要额外注入 Name (_PRW, Package (0x02) {0x1C,0x03})。\nFixRTC：参考 OC-little 的「声卡 IRQ 补丁」章节\nFixTIMR：参考 OC-little 的「声卡 IRQ 补丁」章节\nAddPNLF：参考 OC-little 的「注入 PNLF」章节\nAddIMEI：使用 WhateverGreen 即可\nFixIntelGfx：使用 WhateverGreen 即可\nAddHDMI：使用 WhateverGreen 即可\n除了这些开关以外，Clover 还有一些其它的 ACPI 设定，也有与之对应的替代。\n\nDisableASPM：没有很好的代替方法，可以在设备属性（DeviceProperties）中分别添加相关设备的 PCI 总线位置并注入属性 pci-aspm-default | DATA | <00>。\nPluginType：参考 OC-little 的「注入 X86」章节\nGenerate P States 和 Generate C States：这些是六代以前 CPU 才需要的设置，可以用 ssdtPRGen.sh 生成对应的 SSDT。\n当然之后的事情还是一样的，以 -v 重启，正常开机后打开终端查看日志中是否包括 ACPI Error：\n\n$ log show --last boot | grep -Ei \"ACPI\"\n当你把所有 Clover 的开关都用 SSDT 代替以后，你离迁移到 OpenCore 就越来越近了。\n\n更新设备属性\n使用缓冲帧补丁驱动 Intel 核显\n如果你还在用 Clover 的 InjectIntel 的方式来驱动 Intel 核显的话，是时候更换到 WhateverGreen 和缓冲帧补丁的方式了。\n\n建议参考以下几篇文章：\n\n使用 WhateverGreen 驱动 Intel 核显 | 醉渔小站\nHackintool(原Intel FB-Patcher)使用教程及插入姿势 | 黑果小兵的部落阁\nIntel 核显驱动常见问题 | WhateverGreen （务必看英文版，中文翻译严重过时）\n新的声卡 layout-id 注入方式\n大部分黑苹果的声卡教程都已经推荐此处留空、直接在设备属性中注入 layout-id 了，不过我还是再冗笔一下。\n\n下载 acidanthera 开发的工具 gfxutils，使用下述命令找出声卡的 PCI 总线位置：\n\n$ path/to/gfxutils -f HDEF\n$ path/to/gfxutils -f HDAS\n$ path/to/gfxutils -f HDAU\n然后在设备属性中添加 PCI 总线位置、注入 layout-id 属性。\n\n至于 AFGLowPowerState，需要额外为声卡设备注入 AFGLowPowerState 属性，值为 DATA | <01000000>、至于 ResetHDA，推荐安装 JackFix。\n\n开始组织 OpenCore 目录\n终于是时候了，所有的准备工作都做完了！你可以抽出一天（最好占卜一下是否是吉日），沐浴更衣，然后开始组织你的 OpenCore 目录。\n\n下载 OpenCore 所需文件\nOpenCorePkg - OpenCore 本体、一些 SSDT 补丁、目录结构\nMacInfoPkg - 导出你当前的三码、以及生成新的三码\nAppleSupportPkg - 包括三个 EFI 驱动，ApfsDriverLoader、VBoxHfs、AudioDxe\nOcBinaryData - 包含两个闭源驱动 HfsPlus.efi 和 ExFatDxe.efi，以及 OpenCore 官方主题的图标文件。\n非常推荐安装 OpenCore 官方做的主题，和真 Mac 的 BootPicker 一模一样（除了没有网络图标）。不过那可能是另一篇文章的主题了。\n决定你使用的配置文件编辑器\nProperTree：一个 Python 编写的 plist 编辑器，专门优化了 OpenCore 和 Clover 配置文件编写。\nXcode：非常不推荐，Xcode 11 不仅花里胡哨、而且处理 plist data 和大整数方面存在问题。\n简单来说，Apple 没有再开放旧版的 Xcode 10 下载、而且 Apple 的 CDN 还有防盗链。因此如果我要写一篇从 Apple 官方下载 Xcode 10 的教程，那么会比你现在看的这篇的「从 Clover 到 OpenCore」要长得多。\n如果你和我一样成功下载了 Xcode 10 或者就没有升级到 Xcode 11：我刚才什么都没写，你什么都没看见。\nOpenCore Configurator：Clover Configurator 作者的新作品。很适合新手使用。\nOpenCore 的配置文件变更非常频繁，因此只应该用 最新版的 OpenCore Configurator 搭配 最新的正式版的 OpenCore，否则配置文件格式错误将会导致无法引导。\nOpenCore Configurator 有不少低级 Bug（后来更新时都修复了），比如之前有一个版本，在应对 VoodooPS2Controller 和 VooooI2C 这种嵌套 kext 时，会只添加内部 kext 的 dsYM 签名文件、却不添加内部 kext 本体。\n反正就是，使用后果自负。\n生成目录结构\n解压下载的 OpenCore 并解压，将其中的 EFI 目录 复制出来到别处。\n\n直到配置好以后，再将这个目录合并进硬盘上的 EFI 分区。\n\n将 Docs 目录下的 Sample.list 复制到 EFI/OC 目录下、并重命名为 config.plist。\n\n如果你下载的是 OpenCore 0.5.7 版本，还需要额外将 Reources 目录复制到 EFI/OC 目录之中。\n\n解压下载的 AppleSupportPkg，将其中的 Drivers 目录和 Tools 目录中的文件复制到 EFI/OC/Drivers 目录和 EFI/OC/Tools 目录中。\n\n解压下载的 OcBinaryData，将其中 Drivers 目录复制到 EFI/OC/Drivers 目录中。\n\n删除不需要的文件\n删除 Drivers 目录中的这些文件：\n\nExFatDxe 和 ExFatDxeLegacy：除非你的 EFI 分区或者某个系统分区是 ExFAT 分区格式的，否则不需要保留。\nHfsPlus、HfsPlusLegacy 和 VBoxHfs：三者只要留其中一个即可。一般推荐用 HfsPlus，比 VBoxHfs 速度快三倍。在四代以前机型上应该用 HfsPlusLegcay 而不是 HfsPlus。\nAppleUsbKbDxe 或 OpenUsbKbDxe：这是为三代以前机型使用的，现代的机器应该使用 OpenCore 中的 KeySupport 这个 Quirk。\nNvmExpressDxe：这是为四代以前机型使用的 NVMe 硬盘加载驱动，现代的机器已经不需要了。\nXhciDxe：为二代以前的主板提供 XHCI 支持的，现代的机器已经不需要了。\nHiiDatabase：为四代以前的设备提供 UEFI 界面字体渲染支持的，现代的机器已经不需要了。\n删除 Tools 目录中的这些文件：\n\nBootKicker：调用 Mac 内置的引导界面，是用于给白苹果安装 OpenCore 时用的，黑苹果用不上。\n现在，你的 OpenCore EFI 目录的结构应该是这样的：\n\nEFI\n├── BOOT\n│   └── BOOTx64.efi\n└── OC\n    ├── ACPI\n    ├── Drivers\n    │   ├── ApfsDriverLoader.efi\n    │   ├── AudioDxe.efi\n    │   ├── HfsPlus.efi\n    │   ├── OpenCanopy.efi\n    │   └── OpenRuntime.efi\n    ├── Kexts\n    ├── OpenCore.efi\n    ├── Resources\n    └── Tools\n        ├── ChipTune.efi\n        ├── ......\n        └── VerifyMsrE2.efi\n现在，你可以把你的 SSDT、DSDT 从 Clover 里的 Clover/ACPI/Patched 复制出来、粘贴进 EFI/OC/ACPI 目录中；将 Kext 从 Clover/Kexts/*/ 中复制出来粘贴进 EFI/OC/Kexts 目录中。\n\n开始配置 OpenCore\n这里我就不再赘述 OpenCore 的配置教程了。这里推荐几个写的不错的教程和足够有用的参考资料。\n\nOpenCore 参考文档。当你解压下载的 OpenCore 时，Docs/Configuration.pdf 文件就是 OpenCore 的官方文档。这是最权威的 OpenCore 参考资料、没有之一。\nOpenCore 简体中文参考手册。OpenCore 参考手册的翻译，由我和一些黑苹果爱好者们共同在维护。\n上面两份参考资料资料适合你在配置时不知道某个选项的具体作用、具体副作用时参考用，但是不适合直接对着它们配置 config.plist。\n如果想要快速上手 OpenCore 配置，应该参考下面的教程：\n\nOpenCore Vanilla Guide。OpenCore 官方认可写得较好的新手教程。这篇教程受众是第一次接触黑苹果就想用 OpenCore 的人，因此内容写得非常浅显\n精解 OpenCore | 黑果小兵的部落阁。国内最早的 OpenCore 介绍文档之一，提供了不少配置思路和 Quirks 的推荐配置。\n使用 OpenCore 引导黑苹果 | XJN’s Blog。比较详细的 OpenCore 配置介绍，但是这篇文章的排版我实在是欣赏不来。\nOpenCore 引导迁移折腾记录 | 宇宙よりも遠い場所。内容详细的 OpenCore 配置介绍，提供了不少 Quirks 的推荐配置。\nClover 中的部分配置，如 DSDT 重命名，由于在之前已经精简，因此可以将 Find 和 Replace 的十六进制字符串逐对复制到 OpenCore 的配置文件中。\n\nClover 中的设置在 OpenCore 的等效配置\n现在你开始跟着我推荐的教程和参考资料开始配置 OpenCore 了。接下来我会写一些 Clover 中一些选项在 OpenCore 的对应等效配置，在配置 OpenCore 时别忘了跟着看看。\n\nBoot 的相关设置\n引导参数：OpenCore 中 NVRAM -> Add -> 7C436110-AB2A-4BBB-A880-FE41995C9F82 -> boot-args\nNeverHibernate：Misc -> Boot -> HibernateMode -> None\n其实不再建议禁用休眠，由于 OpenCore 的行为和白苹果更加接近，以至于已经可以实现 macOS 的完美休眠。\nDefault Boot Volume：OpenCore 中 Misc - Security - AllowSetDefaults - true\n然后在 OpenCore 的引导菜单处使用 Ctrl + Enter 按键进行选择\n你也可以直接用「系统偏好设置」中的「启动磁盘」设置\nDefaultBackgroundColor：OpenCore 中的 NVRAM -> Add -> 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14-> DefaultBackgroundColor ，需要自己将 RGB 转换为 HEX。\nEFILoginHiDPI：OpenCore 中 NVRAM -> Add -> 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14 -> EFILoginHiDPI | Data | <>\n0 -> <00000000>\n1 -> <01000000>\nflagstate：OpenCore 中 NVRAM -> Add -> 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14 -> flagstate | Data | <>\n0 -> <00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000>\n注意自行判断 NVRAM 键值对位置\nUIScale：NVRAM -> Add -> 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14 -> UIScale | Data | <>\n1 -> <01>\n2 -> Data | <02>\nCPU 相关配置\nType：在 OpenCore 中有对应的 Platforminfo -> SMBIOS -> ProcessorType 可以设置处理器类型\n在 这个文件 查看可以选用的值\nHWPEnable：如果你真的要依赖 MSR 0x770 （注意这里说的不是原生电源管理 MSR 0xe2）的 HWP 电源管理，建议安装 headkaze 开发的 HWPEnable.kext。HackinTool 也是他开发的。\nQEMU：OpenCore 已经完整支持虚拟机，因此 OpenCore 中不包含这一选项。\nTurboDisable：建议用 CPUFriend 或者 ssdtPRGen.sh 来修复电源管理。\n设备属性相关设置\nUSB\nFixOwnership：OpenCore 中 UEFI -> Quirk -> ReleaseUsbOwnership\nClockID：需要自己注入对应的设备属性（Device Properties），属性为 AAPL,clock-id\nHighCurrent：需要自己注入对应的设备属性（Device Properties），属性为 AAPL,HighCurrent\n对于 macOS 10.11 来说 HighCurrent 已经没啥用了。对于更新版的 macOS，推荐用 OC-little 中的 SSDT-USBX 补丁。\nFakeID\n同样使用 gfxutils 工具找到 PCI 总线位置，然后分别注入相关属性：\n\nUSB\ndevice-id\ndevice_type\ndevice_type\nIMEI\ndevice-id\nvendor-id\nWIFI\nname\ncompatible\nLAN\ndevice-id\ncompatible\nvendor-id\nXHCI\ndevice-id\ndevice_type: UHCI\ndevice_type: OHCI\ndevice_type: EHCI\ndevice-id\nAAPL,current-available\nAAPL,current-extra\nAAPL,current-available\nAAPL,current-extra\nAAPL,current-in-sleep\nbuilt-in\ndevice_type: XHCI\ndevice-id\nAAPL,current-available\nAAPL,current-extra\nAAPL,current-available\nAAPL,current-in-sleep\nbuilt-in\nClover 中相关的图形设置\n和前文一样，这些在 Clover 中设置的属性都需要改为注入对应的设备属性即可。\n\nInjectAti:\nDeviceProperties -> Add -> PCIRoot... -> deviceID\nDeviceProperties -> Add -> PCIRoot... -> Connectors\nInjectNvidia:\nDeviceProperties -> Add -> PCIRoot... -> DeviceID\nDeviceProperties -> Add -> PCIRoot... -> Family\nFakeAti:\nDeviceProperties -> Add -> PCIRoot... -> device-id\nDeviceProperties -> Add -> PCIRoot... -> ATY,DeviceID\nDeviceProperties -> Add -> PCIRoot... -> @0,compatible\nDeviceProperties -> Add -> PCIRoot... -> vendor-id\nDeviceProperties -> Add -> PCIRoot... -> ATY,VendorID\nBootDisplay:\nDeviceProperties -> Add -> PCIRoot... -> @0,AAPL,boot-display\nIntel 核显推荐使用 WhateverGreen 和缓冲帧补丁驱动。\n\n一般的，在注入仿造显卡或仿造 VBIOS 的时候，更推荐使用 SSDT 搭配 WhateverGreen 的方式。至于 EDID 注入，WhateverGreen 的文档中有 详细介绍。\n\n内核扩展驱动（Kext）相关\nKernelPm 和 AppleIntelCPUPM：对应 OpenCore 中 Kernel -> Quirks -> AppleXcpmCfgLock -> YES 和 Kernel -> Quirks -> AppleCpuPmCfgLock -> YES。\nDellSMBIOSPatch ：在 OpenCore 中对应了两个 Quirk：\nKernel -> Quirks -> CustomSMBIOSGuid -> YES\nPlatformInfo -> UpdateSMBIOSMode -> Custom\nKernel LAPIC 和 KernelXCPM：分别对应 OpenCore 中的 Kernel -> Quirks -> LapicKernelPanic -> YES 和 Kernel -> Quirks -> AppleXcpmExtraMsrs -> YES\nAppleRTC：\nComment：Disable RTC checksum update on poweroff\nEnabled：YES\nCount：1\nBase：__ZN8AppleRTC14updateChecksumEv\nIdentifier：com.apple.driver.AppleRTC\nLimit：0\nFind：\nReplace：c3\nFakeCPUID：OpenCore 提供了专门的 Emulate 功能。\n除此以外，一些常用的 Kext Patch 在 OpenCore 中也有了对应了 Quirk。\n\n解除 USB 15 端口限制，以前根据不同的系统需要打不同的 Kext Patch，现在只需要 OpenCore 一个 Quirk：Kernel -> Quirks -> XhciPortLimit -> YES\n内置硬盘变外置硬盘，也只需要一个 Quirk：kernel -> Quirks -> ExternalDiskIcons -> YES\n和前面的 FixSATA 不同，FixSATA 顾名思义只修复 SATA 硬盘，而 OpenCore 这个 Quirks 会修复所有的硬盘。\n为 SATA SSD 提供 TRIM 现在也只需要启用一个 Quirk：Kernel -> Quirks -> ThirdPartyDrive\nSMBIOS 机型信息和系统参数\nProduct Name：PlatformInfo -> Generic -> SystemProductName\nSerial Number：PlatformInfo --> Generic -> SystemSerialNumber\nBoard Serial Number：PlatformInfo -> Generic -> MLB\nSmUUID：PlatformInfo -> Generic -> SystemUUID\nSlots AAPL Injection：需要注入到设备属性中\nDeviceProperties -> Add -> PCIRoot... -> APPL,slot-name | string | Add slot\nCustomUUID：就连 Clover 都不推荐配置这一项，OpenCore 直接就不提供硬件 UUID 配置功能\nInjectSystemID：兼容变色龙的历史遗留配置，OpenCore 也不再提供\nBacklightLevel：需要注入到 NVRAM 中\nNVRAM -> Add -> 7C436110-AB2A-4BBB-A880-FE41995C9F82 -> backlight-level | Data | <Insert value>\nNvidiaWeb：需要注入到 NVRAM 中\nNVRAM -> Add -> 7C436110-AB2A-4BBB-A880-FE41995C9F82 -> nvda_drv: <31>\n配置好 OpenCore 以后，可以将 OpenCore 复制到 U 盘或者硬盘中。需要注意的是，EFI/BOOT/BOOTx64.efi 需要直接替换。在添加引导项时，OpenCore 必须 从 EFI/BOOT/BOOTx64.efi 启动而不是从 EFI/OC/OpenCore.efi 启动。如果启动项中添加的不是 EFI/BOOT/BOOTx64.efi，那么有很大的概率你会遇到各种奇怪的问题。\n\n清理 Clover 残余\n重启到 OpenCore 引导之前，务必清理掉 Clover 的残留文件：\n\nsudo rm -rf /Library/PreferencePanes/Clover.prefPane # 删除 `Clover` 位于系统偏好设置中的面板\n# 删除 `Clover` 的自动脚本\nrm -rf \"/etc/rc.clover.lib\"\nrm -rf \"/etc/rc.boot.d/10.save_and_rotate_boot_log.local\"\nrm -rf \"/etc/rc.boot.d/20.mount_ESP.local\"\nrm -rf \"/etc/rc.boot.d/70.disable_sleep_proxy_client.local.disabled\"\nrm -rf \"/etc/rc.boot.d/80.save_nvram_plist.local\"\nrm -rf \"/etc/rc.shutdown.local\"\nrm -rf \"/etc/rc.boot.d\"\nrm -rf \"/etc/rc.shutdown.d\"\n# 删除 `Clover` 的守护进程\nlaunchctl unload '/Library/LaunchDaemons/com.slice.CloverDaemonNew.plist'\nrm -rf '/Library/LaunchDaemons/com.slice.CloverDaemonNew.plist'\nrm -rf '/Library/Application Support/Clover/CloverDaemonNew'\nrm -rf '/Library/Application Support/Clover/CloverLogOut'\nrm -rf '/Library/Application Support/Clover/CloverWrapper.sh'\n除此以外，还要删除 EFI 分区中的 nvram.plist 文件。\n\n在 OpenCore 中还需要重置 NVRAM。可以在 OpenCore 引导菜单中，按下空格键显示隐藏条目，最后一个条目就是 OpenCore 的重置 NVRAM 功能。\n\n原文链接：\nhttps://blog.skk.moe/post/from-clover-to-opencore/\n\n感谢名单\nApple 的 macOS\nRehabMan维护的项目：OS-X-Clover-Laptop-Config Laptop-DSDT-Patch OS-X-USB-Inject-All等\nAcidanthera 维护的项目：OpenCorePkg lilu AirportBrcmFixup WhateverGreen VirtualSMC AppleALC BrcmPatchRAM MaciASL 等\nheadkaze 提供的工具：hackintool PinConfigurator BrcmPatchRAM\nCloverHackyColor维护的项目：CloverBootloader CloverThemes\n宪武整理的：P-little OC-little\nchris1111维护的项目：VoodooHDA Wireless USB Adapter Clover\nzxystd开发的itlwm IntelBluetoothFirmware\nlihaoyun6提供的工具：CPU-S macOS-Displays-icon SidecarPatcher\nsukka更新维护的从 Clover 到 OpenCore —— Clover 迁移 OpenCore 指南\nxzhih提供的工具：one-key-hidpi\nBat.bat更新维护的精解OpenCore\nshuiyunxc 更新维护的OpenCore配置错误、故障与解决办法\nathlonreg更新维护的OpenCore 0.5+ 部件补丁 Common-patches-for-hackintosh\ngithub.com\n码云 gitee.io\n扣钉 coding.net\n参考及引用：\nhttps://deviwiki.com/wiki/Dell\nhttps://deviwiki.com/wiki/Dell_Wireless_1820A_(DW1820A)\nHervé 更新的Broadcom 4350:https://osxlatitude.com/forums/topic/12169-bcm4350-cards-registry-of-cardslaptops-interop/\nHervé 更新的DW1820A支持机型列表:https://osxlatitude.com/forums/topic/11322-broadcom-bcm4350-cards-under-high-sierramojave/\nnickhx 提供的蓝牙驱动：https://osxlatitude.com/forums/topic/11540-dw1820a-for-7490-help/?do=findComment&comment=92833\nxjn819： 使用OpenCore引导黑苹果 300系列主板正确使用AptioMemoryFix.efi的姿势(重写版）\ninsanelymac.com\ntonymacx86.com\n远景论坛\napplelife.ru\nolarila.com","tags":["黑苹果"],"categories":["tech"]},{"title":"(⊙o⊙)…","url":"//post/⊙o⊙-….html","content":"\n(⊙o⊙)…","tags":["其他"],"categories":["tech"]}]